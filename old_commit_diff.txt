commit d32714076f4763d51b653e75f280f2ac2371e293
Author: cw523-01 <78119212+cw523-01@users.noreply.github.com>
Date:   Fri Jun 20 14:57:59 2025 +0100

    moved FSA property checks to the backend

diff --git a/fsa_sim/settings.py b/fsa_sim/settings.py
index edfa508..3132295 100644
--- a/fsa_sim/settings.py
+++ b/fsa_sim/settings.py
@@ -25,7 +25,9 @@ SECRET_KEY = 'django-insecure-j#qejc2tu*nnf9!hft2ldb#%c3+zvf#)-^n-749drl8c(qhr92
 # SECURITY WARNING: don't run with debug turned on in production!
 DEBUG = True
 
-ALLOWED_HOSTS = []
+ALLOWED_HOSTS = [
+    '*',
+]
 
 
 # Application definition
diff --git a/simulator/fsa_properties.py b/simulator/fsa_properties.py
new file mode 100644
index 0000000..bdc643f
--- /dev/null
+++ b/simulator/fsa_properties.py
@@ -0,0 +1,218 @@
+from typing import Dict, List, Set
+from collections import deque
+
+
+def is_deterministic(fsa: Dict) -> bool:
+    """
+    Checks if the FSA is deterministic.
+
+    An FSA is deterministic if:
+    1. It has no epsilon transitions
+    2. For each state and each symbol, there is exactly one transition
+
+    Args:
+        fsa: A dictionary representing the FSA with the following keys:
+            - states: List of all states
+            - alphabet: List of symbols in the alphabet
+            - transitions: Dictionary of transitions
+            - startingState: The starting state
+            - acceptingStates: List of accepting states
+
+    Returns:
+        bool: True if the FSA is deterministic, False otherwise
+    """
+    # Handle empty alphabet case - trivially deterministic
+    if not fsa.get('alphabet') or len(fsa['alphabet']) == 0:
+        return True
+
+    # Check for epsilon transitions
+    for state in fsa.get('states', []):
+        if state in fsa.get('transitions', {}) and '' in fsa['transitions'][state]:
+            if fsa['transitions'][state]['']:  # Non-empty epsilon transitions
+                return False
+
+    # For each state and each symbol, check if there is exactly one transition
+    for state in fsa.get('states', []):
+        if state not in fsa.get('transitions', {}):
+            continue
+
+        for symbol in fsa['alphabet']:
+            if symbol in fsa['transitions'][state]:
+                transitions = fsa['transitions'][state][symbol]
+                # If there is more than one transition, the FSA is not deterministic
+                if len(transitions) > 1:
+                    return False
+
+    return True
+
+
+def is_complete(fsa: Dict) -> bool:
+    """
+    Checks if the FSA is complete.
+
+    An FSA is complete if for each state and each symbol, there is at least one transition.
+    Epsilon transitions are ignored for completeness check.
+
+    Args:
+        fsa: A dictionary representing the FSA
+
+    Returns:
+        bool: True if the FSA is complete, False otherwise
+    """
+    # Handle empty cases
+    if not fsa.get('states') or len(fsa['states']) == 0:
+        return True  # Trivially complete if no states
+
+    if not fsa.get('alphabet') or len(fsa['alphabet']) == 0:
+        return True  # Trivially complete if no alphabet
+
+    # For each state and each symbol, check if there is at least one transition
+    for state in fsa['states']:
+        if state not in fsa.get('transitions', {}):
+            return False
+
+        for symbol in fsa['alphabet']:
+            if symbol not in fsa['transitions'][state]:
+                return False
+
+            transitions = fsa['transitions'][state][symbol]
+            # If there are no transitions, the FSA is not complete
+            if len(transitions) == 0:
+                return False
+
+    return True
+
+
+def is_connected(fsa: Dict) -> bool:
+    """
+    Checks if the FSA is connected.
+
+    An FSA is connected if all states are reachable from the starting state.
+
+    Args:
+        fsa: A dictionary representing the FSA
+
+    Returns:
+        bool: True if the FSA is connected, False otherwise
+    """
+    # Handle empty states case
+    if not fsa.get('states') or len(fsa['states']) == 0:
+        return True  # Trivially connected if no states
+
+    # If there's no starting state, the FSA can't be connected (unless only one state)
+    if not fsa.get('startingState'):
+        return len(fsa['states']) <= 1
+
+    # If starting state is not in states list, not connected
+    if fsa['startingState'] not in fsa['states']:
+        return False
+
+    # If there's only one state, it's trivially connected
+    if len(fsa['states']) <= 1:
+        return True
+
+    # Handle case where transitions don't exist
+    if not fsa.get('transitions'):
+        return len(fsa['states']) <= 1
+
+    # Use BFS to find all reachable states from the starting state
+    reachable_states = set()
+    queue = deque([fsa['startingState']])
+    reachable_states.add(fsa['startingState'])
+
+    while queue:
+        current_state = queue.popleft()
+
+        # Safety check: make sure currentState exists in transitions
+        if current_state not in fsa['transitions']:
+            continue
+
+        # Create symbols array including epsilon transitions
+        symbols_to_check = list(fsa.get('alphabet', []))
+        if '' in fsa['transitions'][current_state]:
+            symbols_to_check.append('')  # Add epsilon transitions
+
+        # Check all possible transitions from this state
+        for symbol in symbols_to_check:
+            if symbol not in fsa['transitions'][current_state]:
+                continue
+
+            transitions = fsa['transitions'][current_state][symbol]
+
+            for next_state in transitions:
+                if next_state not in reachable_states:
+                    reachable_states.add(next_state)
+                    queue.append(next_state)
+
+    # If all states are reachable, the FSA is connected
+    return len(reachable_states) == len(fsa['states'])
+
+
+def check_all_properties(fsa: Dict) -> Dict:
+    """
+    Check all FSA properties at once.
+
+    Args:
+        fsa: A dictionary representing the FSA
+
+    Returns:
+        Dict: Dictionary containing all property check results:
+        {
+            'deterministic': bool,
+            'complete': bool,
+            'connected': bool
+        }
+    """
+    return {
+        'deterministic': is_deterministic(fsa),
+        'complete': is_complete(fsa),
+        'connected': is_connected(fsa)
+    }
+
+
+def validate_fsa_structure(fsa: Dict) -> Dict:
+    """
+    Validates that the FSA has the required structure for property checking.
+    This is more lenient than before to allow partial FSAs.
+
+    Args:
+        fsa: The FSA dictionary to validate
+
+    Returns:
+        Dict: Validation result with 'valid' boolean and optional 'error' message
+    """
+    if not isinstance(fsa, dict):
+        return {'valid': False, 'error': 'FSA must be a dictionary'}
+
+    required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
+
+    # Check all required keys exist
+    for key in required_keys:
+        if key not in fsa:
+            return {'valid': False, 'error': f'Missing required key: {key}'}
+
+    # Check that values are the right type, but allow empty values
+    if not isinstance(fsa['states'], list):
+        return {'valid': False, 'error': 'states must be a list'}
+
+    if not isinstance(fsa['alphabet'], list):
+        return {'valid': False, 'error': 'alphabet must be a list'}
+
+    if not isinstance(fsa['transitions'], dict):
+        return {'valid': False, 'error': 'transitions must be a dictionary'}
+
+    if not isinstance(fsa['acceptingStates'], list):
+        return {'valid': False, 'error': 'acceptingStates must be a list'}
+
+    # Only check starting state if it exists and there are states
+    if fsa.get('startingState') and fsa.get('states'):
+        if fsa['startingState'] not in fsa['states']:
+            return {'valid': False, 'error': 'Starting state not in states list'}
+
+    # Only check accepting states if there are states
+    if fsa.get('states'):
+        for state in fsa.get('acceptingStates', []):
+            if state not in fsa['states']:
+                return {'valid': False, 'error': f'Accepting state {state} not in states list'}
+
+    return {'valid': True}
\ No newline at end of file
diff --git a/simulator/fsa_simulation.py b/simulator/fsa_simulation.py
index 16e9c3f..d50034f 100644
--- a/simulator/fsa_simulation.py
+++ b/simulator/fsa_simulation.py
@@ -1,5 +1,6 @@
 from typing import Dict, List, Union, Tuple, Optional, Set
 from collections import deque
+from .fsa_properties import is_deterministic
 
 
 def simulate_deterministic_fsa(fsa: Dict, input_string: str) -> Union[List[Tuple[str, str, str]], Dict]:
@@ -27,7 +28,7 @@ def simulate_deterministic_fsa(fsa: Dict, input_string: str) -> Union[List[Tuple
         }
     """
     # Validate the FSA is deterministic
-    if not _is_deterministic(fsa):
+    if not is_deterministic(fsa):
         return {
             'accepted': False,
             'path': [],
@@ -89,27 +90,6 @@ def simulate_deterministic_fsa(fsa: Dict, input_string: str) -> Union[List[Tuple
         }
 
 
-def _is_deterministic(fsa: Dict) -> bool:
-    """
-    Checks if the FSA is deterministic.
-
-    An FSA is deterministic if:
-    1. For each state and each symbol, there is at most one transition
-    2. There are no epsilon transitions (this is assumed)
-    """
-    # Assuming no epsilon transitions
-
-    for state in fsa['states']:
-        for symbol in fsa['alphabet']:
-            # Check if there's a transition for this symbol
-            if symbol in fsa['transitions'][state]:
-                # If there's a transition, ensure it leads to at most one state
-                if len(fsa['transitions'][state][symbol]) > 1:
-                    return False  # Not deterministic (multiple possible next states)
-
-    return True
-
-
 def _has_epsilon_transitions(fsa: Dict) -> bool:
     """
     Check if the FSA has any epsilon transitions.
diff --git a/simulator/urls.py b/simulator/urls.py
index a69a71b..e252208 100644
--- a/simulator/urls.py
+++ b/simulator/urls.py
@@ -22,4 +22,10 @@ urlpatterns = [
     # Depth-limited NFA simulators
     path('api/simulate-nfa-depth-limit/', views.simulate_nfa_with_depth_limit, name='simulate_nfa_depth_limit'),
     path('api/simulate-nfa-stream-depth-limit/', views.simulate_nfa_stream_with_depth_limit, name='simulate_nfa_stream_depth_limit'),
+
+    # Property checking endpoints
+    path('api/check-fsa-properties/', views.check_fsa_properties, name='check_fsa_properties'),
+    path('api/check-deterministic/', views.check_deterministic, name='check_deterministic'),
+    path('api/check-complete/', views.check_complete, name='check_complete'),
+    path('api/check-connected/', views.check_connected, name='check_connected'),
 ]
\ No newline at end of file
diff --git a/simulator/views.py b/simulator/views.py
index 40f2391..45c924c 100644
--- a/simulator/views.py
+++ b/simulator/views.py
@@ -12,6 +12,13 @@ from .fsa_simulation import (
     simulate_nondeterministic_fsa_with_depth_limit,
     simulate_nondeterministic_fsa_generator_with_depth_limit
 )
+from .fsa_properties import (
+    is_deterministic,
+    is_complete,
+    is_connected,
+    check_all_properties,
+    validate_fsa_structure
+)
 
 
 def index(request):
@@ -41,13 +48,9 @@ def simulate_fsa(request):
             return JsonResponse({'error': 'Missing FSA definition'}, status=400)
 
         # Validate FSA structure
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
-            return JsonResponse({
-                'error': f'FSA definition is missing required keys: {", ".join(missing_keys)}'
-            }, status=400)
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
 
         # Check if FSA is non-deterministic
         if is_nondeterministic(fsa):
@@ -113,14 +116,10 @@ def simulate_dfa(request):
         if not fsa:
             return JsonResponse({'error': 'Missing FSA definition'}, status=400)
 
-        # Check if the required keys are present in the FSA
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
-            return JsonResponse({
-                'error': f'FSA definition is missing required keys: {", ".join(missing_keys)}'
-            }, status=400)
+        # Validate FSA structure
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
 
         # Simulate the DFA
         result = simulate_deterministic_fsa(fsa, input_string)
@@ -171,13 +170,9 @@ def simulate_nfa(request):
             return JsonResponse({'error': 'Missing FSA definition'}, status=400)
 
         # Validate FSA structure
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
-            return JsonResponse({
-                'error': f'FSA definition is missing required keys: {", ".join(missing_keys)}'
-            }, status=400)
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
 
         # Simulate the NFA
         result = simulate_nondeterministic_fsa(fsa, input_string)
@@ -228,14 +223,10 @@ def simulate_nfa_stream(request):
             )
 
         # Validate FSA structure
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
             def error_generator():
-                missing_keys_str = ', '.join(missing_keys)
-                error_msg = f'FSA definition is missing required keys: {missing_keys_str}'
-                yield f"data: {json.dumps({'error': error_msg})}\n\n"
+                yield f"data: {json.dumps({'error': validation['error']})}\n\n"
 
             return StreamingHttpResponse(
                 error_generator(),
@@ -303,13 +294,9 @@ def check_fsa_type(request):
             return JsonResponse({'error': 'Missing FSA definition'}, status=400)
 
         # Validate FSA structure
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
-            return JsonResponse({
-                'error': f'FSA definition is missing required keys: {", ".join(missing_keys)}'
-            }, status=400)
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
 
         # Check FSA type
         is_nfa = is_nondeterministic(fsa)
@@ -346,13 +333,9 @@ def check_epsilon_loops(request):
             return JsonResponse({'error': 'Missing FSA definition'}, status=400)
 
         # Validate FSA structure
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
-            return JsonResponse({
-                'error': f'FSA definition is missing required keys: {", ".join(missing_keys)}'
-            }, status=400)
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
 
         # Detect epsilon loops
         result = detect_epsilon_loops(fsa)
@@ -440,13 +423,9 @@ def simulate_nfa_with_depth_limit(request):
             return JsonResponse({'error': 'max_depth must be a positive integer'}, status=400)
 
         # Validate FSA structure
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
-            return JsonResponse({
-                'error': f'FSA definition is missing required keys: {", ".join(missing_keys)}'
-            }, status=400)
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
 
         # Simulate the NFA with depth limit
         result = simulate_nondeterministic_fsa_with_depth_limit(fsa, input_string, max_depth)
@@ -539,14 +518,10 @@ def simulate_nfa_stream_with_depth_limit(request):
             )
 
         # Validate FSA structure
-        required_keys = ['states', 'alphabet', 'transitions', 'startingState', 'acceptingStates']
-        missing_keys = [key for key in required_keys if key not in fsa]
-
-        if missing_keys:
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
             def error_generator():
-                missing_keys_str = ', '.join(missing_keys)
-                error_msg = f'FSA definition is missing required keys: {missing_keys_str}'
-                yield f"data: {json.dumps({'error': error_msg})}\n\n"
+                yield f"data: {json.dumps({'error': validation['error']})}\n\n"
 
             return StreamingHttpResponse(
                 error_generator(),
@@ -594,3 +569,162 @@ def simulate_nfa_stream_with_depth_limit(request):
             content_type='text/event-stream',
             status=500
         )
+
+
+@csrf_exempt
+@require_POST
+def check_fsa_properties(request):
+    """
+    Django view to check FSA properties (deterministic, complete, connected).
+
+    Expects a POST request with a JSON body containing:
+    - fsa: The FSA definition in the proper format
+
+    Returns a JSON response with property check results.
+    """
+    try:
+        # Parse the request body
+        data = json.loads(request.body)
+        fsa = data.get('fsa')
+
+        if not fsa:
+            return JsonResponse({'error': 'Missing FSA definition'}, status=400)
+
+        # Validate FSA structure
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
+
+        # Check all properties
+        properties = check_all_properties(fsa)
+
+        return JsonResponse({
+            'properties': properties,
+            'summary': {
+                'total_states': len(fsa['states']),
+                'alphabet_size': len(fsa['alphabet']),
+                'starting_state': fsa['startingState'],
+                'accepting_states_count': len(fsa['acceptingStates']),
+                'has_epsilon_transitions': any(
+                    '' in fsa['transitions'].get(state, {}) and fsa['transitions'][state]['']
+                    for state in fsa['states']
+                )
+            }
+        })
+
+    except ValueError as e:
+        return JsonResponse({'error': str(e)}, status=400)
+    except Exception as e:
+        return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)
+
+
+@csrf_exempt
+@require_POST
+def check_deterministic(request):
+    """
+    Django view to check if an FSA is deterministic.
+
+    Expects a POST request with a JSON body containing:
+    - fsa: The FSA definition in the proper format
+
+    Returns a JSON response with determinism check result.
+    """
+    try:
+        # Parse the request body
+        data = json.loads(request.body)
+        fsa = data.get('fsa')
+
+        if not fsa:
+            return JsonResponse({'error': 'Missing FSA definition'}, status=400)
+
+        # Validate FSA structure
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
+
+        # Check determinism
+        deterministic = is_deterministic(fsa)
+
+        return JsonResponse({
+            'deterministic': deterministic,
+            'type': 'DFA' if deterministic else 'NFA'
+        })
+
+    except ValueError as e:
+        return JsonResponse({'error': str(e)}, status=400)
+    except Exception as e:
+        return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)
+
+
+@csrf_exempt
+@require_POST
+def check_complete(request):
+    """
+    Django view to check if an FSA is complete.
+
+    Expects a POST request with a JSON body containing:
+    - fsa: The FSA definition in the proper format
+
+    Returns a JSON response with completeness check result.
+    """
+    try:
+        # Parse the request body
+        data = json.loads(request.body)
+        fsa = data.get('fsa')
+
+        if not fsa:
+            return JsonResponse({'error': 'Missing FSA definition'}, status=400)
+
+        # Validate FSA structure
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
+
+        # Check completeness
+        complete = is_complete(fsa)
+
+        return JsonResponse({
+            'complete': complete
+        })
+
+    except ValueError as e:
+        return JsonResponse({'error': str(e)}, status=400)
+    except Exception as e:
+        return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)
+
+
+@csrf_exempt
+@require_POST
+def check_connected(request):
+    """
+    Django view to check if an FSA is connected.
+
+    Expects a POST request with a JSON body containing:
+    - fsa: The FSA definition in the proper format
+
+    Returns a JSON response with connectivity check result.
+    """
+    try:
+        # Parse the request body
+        data = json.loads(request.body)
+        fsa = data.get('fsa')
+
+        if not fsa:
+            return JsonResponse({'error': 'Missing FSA definition'}, status=400)
+
+        # Validate FSA structure
+        validation = validate_fsa_structure(fsa)
+        if not validation['valid']:
+            return JsonResponse({'error': validation['error']}, status=400)
+
+        # Check connectivity
+        connected = is_connected(fsa)
+
+        return JsonResponse({
+            'connected': connected
+        })
+
+    except ValueError as e:
+        return JsonResponse({'error': str(e)}, status=400)
+    except Exception as e:
+        return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)
diff --git a/static/js/fsa/backendIntegration.js b/static/js/fsa/backendIntegration.js
index f52fb3d..6d5c3a7 100644
--- a/static/js/fsa/backendIntegration.js
+++ b/static/js/fsa/backendIntegration.js
@@ -1,5 +1,4 @@
 import { generateTransitionTable } from './transitionTableManager.js';
-import { isDeterministic, isConnected } from './fsaPropertyChecker.js';
 import { getStartingStateId } from './stateManager.js';
 import { visualSimulationManager } from './visualSimulationManager.js';
 import { nfaResultsManager } from './nfaResultsManager.js';
@@ -14,21 +13,6 @@ export function convertFSAToBackendFormat(jsPlumbInstance) {
     // Generate transition table data
     const tableData = generateTransitionTable(jsPlumbInstance);
 
-    // Validate that we have a starting state
-    if (!tableData.startingState) {
-        throw new Error('No starting state defined. Please set a starting state.');
-    }
-
-    // Validate that we have at least one state
-    if (tableData.states.length === 0) {
-        throw new Error('No states defined. Please create at least one state.');
-    }
-
-    // Validate that we have an alphabet
-    if (tableData.alphabet.length === 0) {
-        throw new Error('No alphabet defined. Please create at least one transition with symbols.');
-    }
-
     // Convert transitions to the backend expected format
     const backendTransitions = {};
 
@@ -49,12 +33,13 @@ export function convertFSAToBackendFormat(jsPlumbInstance) {
     });
 
     // Create the FSA object in backend expected format
+    // Allow empty/null values for incomplete FSAs
     const fsa = {
-        states: tableData.states,
-        alphabet: tableData.alphabet,
+        states: tableData.states || [],
+        alphabet: tableData.alphabet || [],
         transitions: backendTransitions,
-        startingState: tableData.startingState,
-        acceptingStates: tableData.acceptingStates
+        startingState: tableData.startingState || null,
+        acceptingStates: tableData.acceptingStates || []
     };
 
     return fsa;
@@ -67,16 +52,30 @@ export function convertFSAToBackendFormat(jsPlumbInstance) {
  */
 export function validateFSAForSimulation(jsPlumbInstance) {
     try {
-        // Check if FSA is connected
-        if (!isConnected(jsPlumbInstance)) {
+        // Convert to backend format (this won't throw anymore)
+        const fsa = convertFSAToBackendFormat(jsPlumbInstance);
+
+        // For simulation, we still need these requirements
+        if (!fsa.startingState) {
             return {
                 success: false,
-                message: 'FSA must be connected for simulation. Please ensure all states are reachable from the starting state.'
+                message: 'No starting state defined. Please set a starting state.'
             };
         }
 
-        // Try to convert to backend format (this will catch other issues)
-        const fsa = convertFSAToBackendFormat(jsPlumbInstance);
+        if (fsa.states.length === 0) {
+            return {
+                success: false,
+                message: 'No states defined. Please create at least one state.'
+            };
+        }
+
+        if (fsa.alphabet.length === 0) {
+            return {
+                success: false,
+                message: 'No alphabet defined. Please create at least one transition with symbols.'
+            };
+        }
 
         return {
             success: true,
@@ -92,6 +91,146 @@ export function validateFSAForSimulation(jsPlumbInstance) {
     }
 }
 
+/**
+ * Check FSA properties (deterministic, complete, connected) using backend
+ * @param {Object} fsa - FSA in backend format
+ * @returns {Promise<Object>} - Promise resolving to property check results
+ */
+export async function checkFSAProperties(fsa) {
+    const requestData = { fsa: fsa };
+
+    try {
+        console.log('Checking FSA properties:', requestData);
+
+        const response = await fetch('/api/check-fsa-properties/', {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+            },
+            body: JSON.stringify(requestData)
+        });
+
+        if (!response.ok) {
+            const errorData = await response.json();
+            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
+        }
+
+        const result = await response.json();
+        console.log('FSA properties result:', result);
+
+        return result;
+
+    } catch (error) {
+        console.error('Error during FSA properties check:', error);
+        throw error;
+    }
+}
+
+/**
+ * Check if FSA is deterministic using backend
+ * @param {Object} fsa - FSA in backend format
+ * @returns {Promise<Object>} - Promise resolving to determinism check result
+ */
+export async function checkFSADeterministic(fsa) {
+    const requestData = { fsa: fsa };
+
+    try {
+        console.log('Checking FSA determinism:', requestData);
+
+        const response = await fetch('/api/check-deterministic/', {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+            },
+            body: JSON.stringify(requestData)
+        });
+
+        if (!response.ok) {
+            const errorData = await response.json();
+            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
+        }
+
+        const result = await response.json();
+        console.log('FSA determinism result:', result);
+
+        return result;
+
+    } catch (error) {
+        console.error('Error during FSA determinism check:', error);
+        throw error;
+    }
+}
+
+/**
+ * Check if FSA is complete using backend
+ * @param {Object} fsa - FSA in backend format
+ * @returns {Promise<Object>} - Promise resolving to completeness check result
+ */
+export async function checkFSAComplete(fsa) {
+    const requestData = { fsa: fsa };
+
+    try {
+        console.log('Checking FSA completeness:', requestData);
+
+        const response = await fetch('/api/check-complete/', {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+            },
+            body: JSON.stringify(requestData)
+        });
+
+        if (!response.ok) {
+            const errorData = await response.json();
+            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
+        }
+
+        const result = await response.json();
+        console.log('FSA completeness result:', result);
+
+        return result;
+
+    } catch (error) {
+        console.error('Error during FSA completeness check:', error);
+        throw error;
+    }
+}
+
+/**
+ * Check if FSA is connected using backend
+ * @param {Object} fsa - FSA in backend format
+ * @returns {Promise<Object>} - Promise resolving to connectivity check result
+ */
+export async function checkFSAConnected(fsa) {
+    const requestData = { fsa: fsa };
+
+    try {
+        console.log('Checking FSA connectivity:', requestData);
+
+        const response = await fetch('/api/check-connected/', {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+            },
+            body: JSON.stringify(requestData)
+        });
+
+        if (!response.ok) {
+            const errorData = await response.json();
+            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
+        }
+
+        const result = await response.json();
+        console.log('FSA connectivity result:', result);
+
+        return result;
+
+    } catch (error) {
+        console.error('Error during FSA connectivity check:', error);
+        throw error;
+    }
+}
+
 /**
  * Check for epsilon loops in an FSA
  * @param {Object} fsa - FSA in backend format
@@ -284,8 +423,9 @@ export async function runFSASimulation(jsPlumbInstance, inputString, visualMode
             }
         }
 
-        // Check if FSA is deterministic or non-deterministic
-        const isDFA = isDeterministic(jsPlumbInstance);
+        // Check if FSA is deterministic or non-deterministic using backend
+        const determinismResult = await checkFSADeterministic(validation.fsa);
+        const isDFA = determinismResult.deterministic;
 
         if (isDFA) {
             // Handle DFA simulation (existing logic)
diff --git a/static/js/fsa/fsaPropertyChecker.js b/static/js/fsa/fsaPropertyChecker.js
index e720faa..27eeb43 100644
--- a/static/js/fsa/fsaPropertyChecker.js
+++ b/static/js/fsa/fsaPropertyChecker.js
@@ -1,159 +1,106 @@
-import { generateTransitionTable } from './transitionTableManager.js';
-import { getEpsilonSymbol } from './edgeManager.js';
+import {
+    convertFSAToBackendFormat,
+    checkFSAProperties,
+    checkFSADeterministic,
+    checkFSAComplete,
+    checkFSAConnected
+} from './backendIntegration.js';
 
 /**
- * Checks if the FSA is deterministic
- * An FSA is deterministic if:
- * 1. It has no epsilon transitions
- * 2. For each state and each symbol, there is exactly one transition
+ * Updates the FSA properties display using backend property checks
  * @param {Object} jsPlumbInstance - The JSPlumb instance
- * @returns {boolean} - Whether the FSA is deterministic
  */
-export function isDeterministic(jsPlumbInstance) {
-    // Get the transition table data
-    const tableData = generateTransitionTable(jsPlumbInstance);
+export async function updateFSAPropertiesDisplay(jsPlumbInstance) {
+    try {
+        // Convert FSA to backend format
+        const fsa = convertFSAToBackendFormat(jsPlumbInstance);
+
+        // Check all properties at once
+        const propertiesResult = await checkFSAProperties(fsa);
+        const properties = propertiesResult.properties;
+
+        // Update the deterministic property display
+        const deterministicDisplay = document.querySelector('.fsa-properties .property:nth-child(2) span:last-child');
+        if (deterministicDisplay) {
+            deterministicDisplay.textContent = properties.deterministic ? '✓' : '✗';
+            deterministicDisplay.className = properties.deterministic ? 'checkmark' : 'crossmark';
+        }
 
-    // If there are epsilon transitions, the FSA is not deterministic
-    if (tableData.hasEpsilon) {
-        return false;
-    }
+        // Update the complete property display
+        const completeDisplay = document.querySelector('.fsa-properties .property:nth-child(3) span:last-child');
+        if (completeDisplay) {
+            completeDisplay.textContent = properties.complete ? '✓' : '✗';
+            completeDisplay.className = properties.complete ? 'checkmark' : 'crossmark';
+        }
+
+        // Update the connected property display
+        const connectedDisplay = document.querySelector('.fsa-properties .property:nth-child(1) span:last-child');
+        if (connectedDisplay) {
+            connectedDisplay.textContent = properties.connected ? '✓' : '✗';
+            connectedDisplay.className = properties.connected ? 'checkmark' : 'crossmark';
+        }
 
+        console.log('Updated FSA properties display:', properties);
 
-    // For each state and each symbol, check if there is exactly one transition
-    for (const stateId of tableData.states) {
-        for (const symbol of tableData.alphabet) {
-            // Get the transitions for this state and symbol
-            const transitions = tableData.transitions[stateId][symbol];
+    } catch (error) {
+        console.error('Error updating FSA properties display:', error);
 
-            // If there is not exactly one transition, the FSA is not deterministic
-            if (transitions.length > 1) {
-                return false;
-            }
-        }
+        // Fallback: show error indicators
+        const displays = document.querySelectorAll('.fsa-properties .property span:last-child');
+        displays.forEach(display => {
+            display.textContent = '?';
+            display.className = 'error';
+        });
     }
-
-    // If we get here, the FSA is deterministic
-    return true;
 }
 
 /**
- * Checks if the FSA is complete
- * An FSA is complete if for each state and each symbol, there is at least one transition
+ * Check if FSA is deterministic using backend
  * @param {Object} jsPlumbInstance - The JSPlumb instance
- * @returns {boolean} - Whether the FSA is complete
+ * @returns {Promise<boolean>} - Whether the FSA is deterministic
  */
-export function isComplete(jsPlumbInstance) {
-    // Get the transition table data
-    const tableData = generateTransitionTable(jsPlumbInstance);
-
-    // Ignore epsilon transitions for completeness check
-
-    // For each state and each symbol, check if there is at least one transition
-    for (const stateId of tableData.states) {
-        for (const symbol of tableData.alphabet) {
-            // Get the transitions for this state and symbol
-            const transitions = tableData.transitions[stateId][symbol];
-
-            // If there are no transitions, the FSA is not complete
-            if (transitions.length === 0) {
-                return false;
-            }
-        }
+export async function isDeterministic(jsPlumbInstance) {
+    try {
+        const fsa = convertFSAToBackendFormat(jsPlumbInstance);
+        const result = await checkFSADeterministic(fsa);
+        return result.deterministic;
+    } catch (error) {
+        console.error('Error checking determinism via backend:', error);
+        return false; // Default to non-deterministic on error
     }
-
-    // If we get here, the FSA is complete
-    return true;
 }
 
 /**
- * Checks if the FSA is connected
- * An FSA is connected if all states are reachable from the starting state
+ * Check if FSA is complete using backend
  * @param {Object} jsPlumbInstance - The JSPlumb instance
- * @returns {boolean} - Whether the FSA is connected
+ * @returns {Promise<boolean>} - Whether the FSA is complete
  */
-export function isConnected(jsPlumbInstance) {
-    // Get the transition table data
-    const tableData = generateTransitionTable(jsPlumbInstance);
-
-    // If there's no starting state, the FSA can't be connected
-    if (!tableData.startingState) {
-        return false;
-    }
-
-    // If there's only one state, it's trivially connected
-    if (tableData.states.length <= 1) {
-        return true;
-    }
-
-    // Use BFS to find all reachable states from the starting state
-    const reachableStates = new Set();
-    const queue = [tableData.startingState];
-    reachableStates.add(tableData.startingState);
-
-    while (queue.length > 0) {
-        const currentState = queue.shift();
-
-        // Safety check: make sure currentState exists in transitions
-        if (!tableData.transitions[currentState]) {
-            console.warn(`State ${currentState} not found in transitions during connectivity check`);
-            continue;
-        }
-
-        // Create symbols array
-        const symbolsToCheck = [...tableData.alphabet];
-        if (tableData.hasEpsilon) {
-            symbolsToCheck.push(''); // Use empty string for epsilon transitions
-        }
-
-        // Check all possible transitions from this state
-        for (const symbol of symbolsToCheck) {
-            // Safety check: make sure the symbol exists for this state
-            if (!tableData.transitions[currentState][symbol]) {
-                continue;
-            }
-
-            const transitions = tableData.transitions[currentState][symbol];
-
-            for (const nextState of transitions) {
-                if (!reachableStates.has(nextState)) {
-                    reachableStates.add(nextState);
-                    queue.push(nextState);
-                }
-            }
-        }
+export async function isComplete(jsPlumbInstance) {
+    try {
+        const fsa = convertFSAToBackendFormat(jsPlumbInstance);
+        const result = await checkFSAComplete(fsa);
+        return result.complete;
+    } catch (error) {
+        console.error('Error checking completeness via backend:', error);
+        return false; // Default to incomplete on error
     }
-
-    // If all states are reachable, the FSA is connected
-    return reachableStates.size === tableData.states.length;
 }
 
 /**
- * Updates the FSA properties display
+ * Check if FSA is connected using backend
  * @param {Object} jsPlumbInstance - The JSPlumb instance
+ * @returns {Promise<boolean>} - Whether the FSA is connected
  */
-export function updateFSAPropertiesDisplay(jsPlumbInstance) {
-    const isDeterministicResult = isDeterministic(jsPlumbInstance);
-    const isCompleteResult = isComplete(jsPlumbInstance);
-    const isConnectedResult = isConnected(jsPlumbInstance);
-
-    // Update the deterministic property display
-    const deterministicDisplay = document.querySelector('.fsa-properties .property:nth-child(2) span:last-child');
-    if (deterministicDisplay) {
-        deterministicDisplay.textContent = isDeterministicResult ? '✓' : '✗';
-        deterministicDisplay.className = isDeterministicResult ? 'checkmark' : 'crossmark';
-    }
-
-    // Update the complete property display
-    const completeDisplay = document.querySelector('.fsa-properties .property:nth-child(3) span:last-child');
-    if (completeDisplay) {
-        completeDisplay.textContent = isCompleteResult ? '✓' : '✗';
-        completeDisplay.className = isCompleteResult ? 'checkmark' : 'crossmark';
+export async function isConnected(jsPlumbInstance) {
+    try {
+        const fsa = convertFSAToBackendFormat(jsPlumbInstance);
+        const result = await checkFSAConnected(fsa);
+        return result.connected;
+    } catch (error) {
+        console.error('Error checking connectivity via backend:', error);
+        return false; // Default to disconnected on error
     }
+}
 
-    // Update the connected property display
-    const connectedDisplay = document.querySelector('.fsa-properties .property:nth-child(1) span:last-child');
-    if (connectedDisplay) {
-        connectedDisplay.textContent = isConnectedResult ? '✓' : '✗';
-        connectedDisplay.className = isConnectedResult ? 'checkmark' : 'crossmark';
-    }
-}
\ No newline at end of file
+// Make the update function globally available
+window.updateFSAPropertiesDisplay = updateFSAPropertiesDisplay;
\ No newline at end of file
